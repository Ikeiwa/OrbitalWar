// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Boid
{
	float3 pos;
	float3 velocity;
};

RWStructuredBuffer<Boid> boidBuffer;
float deltaTime;
float3 volume;
float boidsCount;

sampler3D _Scene;

float3 rule1(uint boid){
    float3 center = 0;

    [loop]
	for (int i = 0; i < boidsCount; i++)
	{
		if (i != int(boid))
		{
            center += boidBuffer[i].pos;
		}
	}
    center /= boidsCount-1;

    return (center-boidBuffer[boid].pos) / 100;
}

float3 rule2(uint boid){
    float3 c = 0;
    float numClose = 1;
    [loop]
	for (int i = 0; i < boidsCount; i++)
	{
		if (i != int(boid))
		{
            if(distance(boidBuffer[boid].pos,boidBuffer[i].pos) < 1){
                c -= normalize(boidBuffer[i].pos - boidBuffer[boid].pos);
                numClose++;
            }
		}
	}
    return c/numClose/8;
}

float3 rule3(uint boid){
    float3 pv = 0;
    [loop]
	for (int i = 0; i < boidsCount; i++)
	{
		if (i != int(boid))
		{
            pv += boidBuffer[i].velocity;
		}
	}
    pv /= boidsCount-1;

    return (pv - boidBuffer[boid].velocity) / 8;
}

float3 rule4(uint boid){
    float sceneValue = tex3Dlod(_Scene, float4(boidBuffer[boid].pos+boidBuffer[boid].velocity,0)).a;

    return -boidBuffer[boid].velocity*sceneValue;
}

[numthreads(128,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    Boid boid = boidBuffer[id.x];

    float3 v1 = rule1(id.x);
    float3 v2 = rule2(id.x);
    float3 v3 = rule3(id.x);
    float3 v4 = rule4(id.x);

    boid.velocity += (v1+v2+v3+v4) * deltaTime * 50;
    boid.pos += boid.velocity * deltaTime;

    boidBuffer[id.x] = boid;
}


